Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з дисципліни «Архітектура програмного забезпечення»
Тема роботи: «Програмна система для автоматизації роботи мобільних аптек»


Виконав
ст. гр. ПЗПІ-21-1                                                                                  Бойченко М. Ю.

Керівник:
доц. каф. ПІ	         	Лещинський В. О.

Робота захищена на оцінку                                                      	        _______________

Комісія:
доц. каф. ПІ	         	Лещинський В. О.
доц. каф. ПІ	         	Лещинська І. О.
ст. викл. каф. ПІ	         	Сокорчук І. П.


	Харків 2024
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії
Спеціальність 121 – Інженерія програмного забезпечення
Курс           3		 Семестр  			            6				____
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Бойченку Матвію Юрійовичу
1.	Тема роботи: «Програмна система для автоматизації роботи мобільних аптек»
2.	Термін узгодження завдання курсової роботи «01» квітня 2024 р.
3.	Термін здачі студентом закінченої роботи «___»___________ 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
реалізація чотирьох компонентів (Back-end, Front-end, Mobile app, IoT), унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, пітримка інтернаціоналізації, локалізація, забезпечення конфіденційності та адміністрування системи
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram
КАЛЕНДАРНИЙ ПЛАН

Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проєкту	01.04.24
2	Проєктування програмного
проєкту	29.04.24
3	Кодування програмного проєкту	28.05.24
4	Оформлення пояснювальної
записки	31.05.24
5	Захист курсової роботи	08.06.24

Дата видачі завдання «01» квітня 2024 р.

Керівник	__________________ доц. Лещинський В.О.
(підпис)
Завдання прийняв до виконання
ст. гр. ПЗПІ-21-1	                 Бойченко М. Ю.
(підпис)





РЕФЕРАТ

	Пояснювальна записка до курсової роботи: 83 с., 43 рис., 2 табл. 4 додатки, 4 джерела.
	АДМІНІСТРАТОР, ЛІКИ, АПТЕКИ, МОБІЛЬНІ, КЛІЄНТ, КОРИСТУВАЧ, ЗАМОВЛЕННЯ, ДОСТАВКА, ПРОГРАМНА СИСТЕМА.
	Об’єктом дослідження є галузь роботи мобільних аптек, а саме створення програмної системи для автоматизації роботи мобільних аптек стосовно замовлення та доставки ліків за допомогою технологій IoT.
	Метою курсової роботи є створення програмної системи, яка дозволяє створювати та відстежувати замовлення ліків. Програмна система дозволить користувачам керувати власним профілем, передивлятись дані про наявні ліки, створювати замовлення, слідкувати за їх виконанням, переглядати історію замовлень.
Методи розробки базуються на технології FastAPI та мові програмування Python, бази даних на ядрі PostgreSQL, інтерфейс базується на біліотеках React, ReactRouter та мові програмування TypeScript, інтеграції IoT-пристроїв з програмним забезпеченням та підтримкою спілкування по протоколу MQTT.
У результаті роботи було розроблену програмну систему для автоматизації роботи мобільних аптек. Програмна система складається з серверної частини для обробки даних, веб-додатку для клієнтів, та MQTT клієнтів IoT-пристрою і моста-черги, через яку він спілкується з серверною частиною.

ЗМІСТ


Вступ	7
1 Аналіз предметної області	8
    1.1 Бізнес-вимоги	8
        1.1.1 Бізнес-можливості	8
        1.1.2 Бізнес-цілі та критерії успіху	9
        1.1.3 Потреби клієнтів або ринку	10
        1.1.4 Бізнес-ризики	Error! Bookmark not defined.11
    1.2 Концепція рішення	Error! Bookmark not defined.3
        1.2.1 Окреслення концепції	Error! Bookmark not defined.3
        1.2.2 Головна функціональність	Error! Bookmark not defined.3
        1.2.3 Припущення та залежності	Error! Bookmark not defined.4
    1.3 Рамки та обмеження проєкту	Error! Bookmark not defined.5
        1.3.1 Рамки первинного випуску	Error! Bookmark not defined.5
        1.3.2 Рамки наступних випусків	16
        1.3.3 Обмеження та винятки	17
    1.4 Бізнес-контекст	18
        1.4.1 Профілі зацікавлених сторін	18
        1.4.2 Пріоритети проєкту	19
        1.4.3 Робоче середовище	20
2 Постановка задачі	21
3 Проєктування бази даних	23
    3.1 Побудова ER-діаграми	Error! Bookmark not defined.3
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	Error! Bookmark not defined.4
4 Архітектура програмної системи	30
    4.1 Архітектура серверної частини	30
    4.2 Архітектура IoT частини	33
    4.3 Архітектура клієнтської частини	39
5 Опис програмної системи	44
    5.1 Виклик і завантаження	44
    5.2 Призначення і логічна структура	46
    5.3 Опис програмної реалізації	47
Висновки	62
Перелік джерел посилання	63
Додаток А Результат перевірки на плагіат	64
Додаток Б Програмний код серверної частини	65
Додаток В Програмний код IoT пристрою	68
Додаток Г Програмний код клієнтської частини    76


ВСТУП


У постійному розвитку медичної інфраструктури людство зіштовхнулося з важливою проблемою: прив'язка до людських ресурсів. Незважаючи на значний прогрес, забезпечення медичними послугами та препаратами залишає багато бажати. У багатьох випадках доступ до медичної допомоги обмежений, особливо у віддалених та важкодоступних регіонах. Сучасні тенденції демонструють, що мобільні аптеки можуть стати важливим рішенням цієї проблеми, пропонуючи можливість доставляти необхідні ліки тим, хто потребує їх найбільше.
Проект “MedMobile” розроблений саме для того, щоб долучитися до вирішення цієї проблеми. Його метою є створення зручної та ефективної системи автоматизації, яка задовольнить потреби різних груп користувачів: споживачів, фармацевтів та логістичних партнерів. “MedMobile” надає можливість швидкого та зручного доступу до медичних препаратів, використовуючи сучасні технології для автоматизації процесів, що значно знижує залежність від людського фактору.
Одним із ключових аспектів “MedMobile” є його здатність працювати в будь-яких умовах. Це означає, що мобільні аптеки можуть бути розгорнуті в найвіддаленіших куточках, де традиційні аптеки недоступні. Це досягається завдяки частковою автоматизацією системи, що зможе функціонувати з мінімальним наглядом від людини. Завдяки цьому, мешканці віддалених регіонів отримують можливість регулярно отримувати необхідні медичні препарати без необхідності подорожувати до найближчого міста.

АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості


Ринок мобільних аптек продовжує розширюватись, пропонуючи значні можливості в районах з обмеженим доступом до стаціонарних аптек. Цей проект спрямований на охоплення цього сегменту, надаючи широкий спектр медичних препаратів із зручністю доставки до віддалених споживачів.
Аналоги системи "MedMobile" на ринку:
–	Мобільна аптека "ФармаДрайв": Перевагою цієї компанії є вже розроблена мережа мобільних аптек, яка дозволяє швидко діставати лікарські засоби в найвіддаленіші райони. Однак система "ФармаДрайв" має обмежену інтеграцію з цифровими платформами, що ускладнює управління запасами та замовленнями в режимі реального часу.
–	Мобільний сервіс "Аптека24": Цей сервіс пропонує високий рівень автоматизації обробки замовлень та ефективне використання баз даних для керування запасами. Однак, незважаючи на технологічні переваги, "Аптека24" має вузький асортимент товарів, що не завжди відповідає потребам всіх категорій споживачів, особливо в сільській місцевості.
"MedMobile" планує вирішити ці недоліки, інтегруючи технології для забезпечення широкого асортименту медикаментів та зручності доступу для всіх користувачів, зокрема використовуючи рішення для підтримки ефективної логістики та замовлень у режимі реального часу.


1.1.2 Бізнес-цілі та критерії успіху


БЦ-1: Ефективна логістика та доступність медикаментів в віддалених районах:
БЦ-1.1: Розробити інтуїтивний інтерфейс для управління запасами лікарських засобів, що дозволяє фармацевтам вчасно реагувати на потреби населення.
БЦ-1.2: Інтеграція системи з застосунком, що надають доступ до інформації про наявність та розташування мобільних аптек в реальному часі.

КУ-1: Досягнення високого рівня задоволеності клієнтів (не менше 80%):
КУ-1.1: Проводити опитування користувачів та фармацевтів для збору відгуків та пропозицій щодо покращення системи.

БЦ-2: Оптимізація внутрішніх процесів та підвищення продуктивності мобільних аптек:
БЦ-2.1: Автоматизація обробки даних та управління запасами для зменшення часу обслуговування та помилок.
БЦ-2.2: Забезпечення надійного зв'язку між мобільними аптеками та центральними базами даних для неперервного оновлення інформації.

КУ-2: Ефективність використання системи:
КУ-2.1: Зменшення часу відповіді на замовлення завдяки автоматизації процесів.
КУ-2.2: Інтеграція з мінімум 50% існуючих мобільних аптек у регіоні протягом першого року впровадження.
БЦ-3: Розширення мережі мобільних аптек:
БЦ-3.1: Збільшення кількості мобільних аптек на 25% протягом першого року за рахунок відкриття нових точок у віддалених районах.
БЦ-3.2: Налагодження партнерства з організаціями охорони здоров'я для забезпечення комплексної підтримки медичних потреб населення.

КУ-3: Висока надійність та доступність системи:
КУ-3.1: Досягнення 90% часу безперервної роботи системи.
КУ-3.2: Розробка системи швидкого реагування на технічні збої та помилки для мінімізації часу простою.


1.1.2	Потреби клієнтів або ринку


Завдяки аналізу ринку, проект " MedMobile " виявив основні потреби та виклики, з якими стикаються клієнти у сфері мобільних аптек, що призвело до розробки цієї програмної системи. Серед критичних потреб клієнтів виділяються:
П-1: Доступність лікарських засобів. Клієнти у віддалених та малодоступних районах потребують надійного доступу до широкого спектру медикаментів, який часто обмежений через логістичні складнощі.
П-2: Швидке та точне виконання замовлень. Необхідність забезпечення оперативного обслуговування клієнтів з високою точністю виконання замовлень та швидкою доставкою важливих медичних препаратів.
П-3: Інтеграція з іншими медичними системами. Мобільні аптеки повинні легко інтегруватися з електронними медичними системами та базами даних для забезпечення синхронізації інформації та забезпечення контролю за здоров'ям пацієнтів.
П-4: Належне зберігання та транспортування медикаментів. Необхідно забезпечити умови для збереження специфічних медикаментів, що вимагають особливих умов зберігання, таких як температурний режим.
П-5: Забезпечення інформаційної підтримки клієнтів. Важливо надати клієнтам доступ до інформації про лікарські засоби, їх застосування та можливі побічні ефекти, а також освітні матеріали з питань здоров'я та профілактики хвороб.
Ці потреби формують базу для розробки функціональності та інтерфейсу системи спрямованих на підвищення задоволеності клієнтів і забезпечення їх медичними потребами в будь-якому місці та будь-коли.


1.1.4 Бізнес-ризики


БР-1: Конкуренція на ринку. Мобільні аптеки стикаються з конкуренцією з боку традиційних стаціонарних аптек та інших мобільних сервісів, які можуть пропонувати схожі послуги або кращі умови співпраці.
БР-2: Логістичні виклики. Забезпечення своєчасної доставки медичних препаратів у віддалені райони може бути ускладнене через погодні умови, стан доріг або інші непередбачувані обставини.
БР-3: Зміни в законодавстві. Нові або змінені законодавчі норми можуть впливати на діяльність мобільних аптек, вимагаючи додаткових витрат на їх дотримання або адаптацію бізнес-моделі.
БР-4: Технологічні збої. Залежність від інформаційних систем та технологій може призвести до критичних збоїв у роботі, якщо система виявиться недостатньо надійною або захищеною.
БР-5: Витоки даних. Ризик незаконного доступу до персональних даних клієнтів або конфіденційної інформації може не тільки призвести до юридичних наслідків, але й підривати довіру клієнтів.
БР-6: Відмова клієнтів від інновацій. Існує ризик, що потенційні користувачі можуть не сприйняти нову систему через звичку до традиційних методів обслуговування або скептицизм щодо нових технологій.
БР-7: Залучення і утримання персоналу. Можливі складнощі з набором та залученням кваліфікованих фахівців, які могли б забезпечити високоякісне обслуговування мобільних аптек.
БР-8: Економічні коливання, такі як інфляція, можуть негативно вплинути на покупну спроможність населення, що зменшить обсяги продажів і прибуток.
Для мінімізації цих ризиків можна вжити кілька заходів, включаючи розробку міцного операційного плану, інвестиції в високоякісне обладнання та його обслуговування, реалізацію ефективних маркетингових стратегій, підтримку актуальності щодо регулятивних вимог, а також надання пріоритету навчанню персоналу та освіті з питань безпеки продуктів та обслуговування клієнтів. Крім того, наявність плану дій на випадок непередбачених подій, таких як несправність обладнання або зміни в попиті, може допомогти мінімізувати вплив цих ризиків на бізнес.


1.2 Концепція рішення
1.2.1 Окреселення концепції


"MedMobile" прагне трансформувати досвід доступу до медичних послуг у віддалених районах, створюючи надійну, ефективну та зручну програмну систему для автоматизації роботи мобільних аптек. Мета проекту полягає у забезпеченні безперервного доступу до медичних препаратів для всіх, хто знаходиться за межами традиційної аптечної інфраструктури. Уявіть світ, де кожен віддалений населений пункт має такий же доступ до аптечних товарів, як і мешканці великих міст. Ми прагнемо забезпечити збалансовані потреби різноманітних клієнтів та розвиваючої організації, орієнтуючись на реалії існуючих і потенційних ринків, стратегічних напрямків організації, а також обмеження за вартістю та ресурсами.


1.2.2 Головна функціональність


MF-1: Інтуїтивний користувацький інтерфейс. Система забезпечує простий та зрозумілий інтерфейс, який дозволяє легко навігувати, робити замовлення та управляти запасами, що значно полегшує використання як для фармацевтів, так і для клієнтів.
MF-2: Реалізація замовлень в режимі реального часу. Функція надає можливість моніторингу та обробки замовлень на медикаменти в реальному часі, що забезпечує оперативну доставку та високу задоволеність клієнтів.
MF-3: Мобільний доступ. Доступ до системи через мобільні пристрої забезпечує зручність використання в будь-якому місці та в будь-який час, підтримуючи мобільність персоналу та клієнтів.
MF-4: Інтеграція з медичними системами. Система інтегрується з існуючими медичними інформаційними системами для забезпечення єдності та синхронізації медичних та логістичних даних.
MF-5: Захист даних. Високий рівень безпеки персональних та транзакційних даних, забезпечений сучасними технологіями шифрування та аутентифікації, гарантує конфіденційність інформації.
MF-6: Підтримка та оновлення. Регулярні оновлення програмного забезпечення забезпечують постійне вдосконалення функціональності та безпеки, а швидке реагування служби підтримки допомагає у вирішенні технічних та оперативних запитань користувачів.


1.2.3 Припущення та залежності


Припущення:
1.	Припускається, що користувачі матимуть доступ до інтернету для використання онлайн-функцій системи.
2.	Припускається, що у всіх регіонах, де буде використовуватися система, є стабільне електропостачання та мобільний зв'язок.
3.	Припускається, що фармацевтичні партнери зможуть забезпечити необхідні медикаменти та відповідати стандартам якості.
Залежності:
1.	Залежність від надійності та точності технологічного обладнання та програмного забезпечення.
2.	Залежність від третіх сторін, зокрема постачальників мобільного зв'язку та інтернет-сервісів.
3.	Залежність від здатності користувачів прийняти та адаптуватися до нової технології управління аптечними запасами.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Первинний випуск програмної системи " MedMobile " спрямований на впровадження ключових функцій, які найбільше впливають на оперативність і зручність доступу до медичних препаратів:
Реєстрація та авторизація користувачів: Фармацевти та клієнти матимуть можливість реєструватися та авторизуватися в системі через веб-інтерфейс або мобільний додаток, що дозволить їм отримати доступ до своїх акаунтів та керувати замовленнями.
Реєстрація машини мобільної аптеки у системі: Робітники зможуть встановлювати на налаштовувати девайси мобільної аптеки у системі за допомогою мобільного додатку налаштувальника.
Інтуїтивно зрозумілий інтерфейс: Ця функція забезпечить зручний та легкий доступ до всіх необхідних інструментів для замовлення та управління запасами медикаментів, що сприятиме ефективному використанню системи як професіоналами, так і клієнтами.
Видача ліків: Клієнти зможуть купляти та отримувати лікі у реальному часі.
Керування девайсами: Фармацевти та адміни системи зможуть оновлювати інформацію про мобільні аптеки та девайси пов’язані із ними.
Пошук ліків: Клієнти зможуть шукати мобільні аптеки із необхідними ліками використовуючи фільтри.
Звіти та аналітика: Функціонал для збору даних та їх аналізу допоможе керівництву аптек та клієнтам краще розуміти тенденції споживання та потреби в медичних препаратах.
Зосередження уваги на цих функціях дозволить досягти максимальної вартості розробки з прийнятними витратами для найширшої спільноти користувачів.


1.3.2 Рамки наступних випусків


Розширені можливості звітності: Додавання функцій для генерації детальних звітів про замовлення та споживання ліків, що дозволить фармацевтам краще планувати закупівлі та оптимізувати запаси. Це також допоможе керівництву аптек аналізувати ефективність поставок та визначати тренди споживання на різних територіях.
Інтеграція з додатковими медичними системами: Включення можливостей для інтеграції з більш широким спектром медичних інформаційних систем, що дозволить забезпечити єдність даних між різними медичними установами та поліпшити координацію догляду за пацієнтами.
Персоналізація інтерфейсу: Можливість користувачам налаштовувати інтерфейс системи згідно з особистими перевагами, що покращить їхній досвід використання системи та збільшить задоволеність сервісом.
Система сповіщень: Введення системи push- та email- сповіщень для пристроїв, яка інформуватиме користувачів про важливі оновлення стану замовлень, необхідність поповнення запасів, або інші критичні події, пов’язані з їхніми замовленнями.
Функції для підтримки рішень: Розробка інструментів, які використовують дані аналітики для надання рекомендацій фармацевтам та керівникам аптек щодо оптимізації асортименту та покращення логістики.
Ці додаткові функції будуть реалізовані з метою забезпечення глибшої інтеграції системи з медичним середовищем, поліпшення зручності та ефективності для кінцевих користувачів, а також для забезпечення більшої адаптивності системи до змінних умов ринку та потреб користувачів.


1.3.3 Обмеження та винятки


Обмеження мобільного зв'язку: Система залежить від стабільності мобільного зв'язку, що може бути обмеженим у деяких віддалених районах.
Функціональність без інтернету: Система не буде функціонувати без доступу до інтернету, що може обмежити її використання в районах без стабільного інтернет-зв'язку.
Обмежена інтеграція зі старим обладнанням: Можливі проблеми з інтеграцією системи з застарілим медичним обладнанням або програмним забезпеченням, що може потребувати додаткових витрат на оновлення.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


	На таблиці 1.1 описані профілі зацікавлених сторін:
Таблиця 1.1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Фармацевти	Ефективне управління запасами та замовленнями	Позитивне, зацікавлене	Оптимізація процесів управління запасами	Доступ до надійного Інтернету та електрики
Клієнти у віддалених районах	Швидкий доступ до медичних препаратів	Високий інтерес до доступності	Зручність замовлення та отримання медикаментів	Обмежений доступ до мобільного зв'язку
Логістичні оператори	Забезпечення ефективної доставки	Співпраця, підтримка	Надійність та точність логістичних процесів	Точність геолокаційних даних
Інвестори	Розвиток нового ринку з високим потенціалом доходів	Орієнтоване на ROI	Швидке окупання інвестицій та розширення на нові ринки	Фінансові ризики, зв'язані з новими технологіями


1.4.2 Пріорітети проєкту


	На таблиці 1.2 наведені пріорітети проєкту:
Таблиця 1.2 – Пріоритети проекту
Показник	Виконання (етапи)	Обмеження
(граничні значення)	Ступінь свободи
(допустимий діапазон)

Розклад/план робіт		Продукт має бути випущеним приблизно до 05.06.2024	Можливе відхилення від графіку на 2-3 місяці
Функціональність			100% функціоналу має працювати на релізі 1.0
Ціна		~66 000 гривень	Допусти ме відхилення на 15%
Персонал		Максимальний розмір команди це 1 розробник та адміністратор
Якість			100% всіх наявних данних з датчиків повинні бути вірними


1.4.3 Робоче середовище


Система "MedMobile" буде використовуватися переважно у віддалених регіонах, що вимагає стабільного мобільного зв'язку та доступу до Інтернету.
Використані технології:
-	Back-end: Python 3.10, FastAPI, SQLAlchemy ORM, Alembic
-	Інтерфейс: TypeScript, React
-	Мобільний додаток: React Native
-	База даних: PostgreSQL
-	Зовнішні API: Брокер AWS IoT Core MQTT (зв’язок з IoT).
Для забезпечення безпеки, буде використано JWT як метод для авторизації та аутентифікації, що додає додатковий шар захисту.
 
2	ПОСТАНОВКА ЗАДАЧІ


Відповідно до попереднього аналізу предметної області, завданням курсової роботи було поставлено створення програмної системи для автоматизації роботи мобільних аптек, що включає роботу з інформацію з ліками, замовленнями та машинами-мобільними аптеками.
База даних повинна включати інформацію про: користувачів, ліки, замовлення, зупинки для видачі ліків, машини з датчиками, дані з датчиків, аналізи та попередження.
Для клієнта має бути реалізований такий функціонал:
–	Реєстрація та вхід в систему;
–	Перегляд та редагування своїх даних, таких як ПІБ, дата народження, пароль та пошта;
–	Перегляд інформації про ліки;
–	Створення та перегляд власних замовлень.
Для клієнта-доставника системи має бути реалізований наступний функціонал:
–	Реєстрація та вхід в систему;
–	Перегляд та редагування своїх даних, таких як ПІБ, пароль та пошта;
–	Перегляд, створення, редагування та видалення власних машин;
–	Перегляд, створення, редагування та видалення зупинок для власних машин;
–	Перегляд даних з датчиків;
–	Приймання та оновлення статусу замовлень на доставку ліків.

Для адміністратора системи має бути реалізований наступний функціонал:
–	Вхід в систему;
–	Перегляд, створення, редагування та видалення користувачів;
–	Перегляд, створення, редагування та видалення машин-датчиків;
–	Перегляд, створення, редагування та видалення налаштувань датчиків;
–	Перегляд, створення, редагування та видалення зупинок для видачі ліків;
–	Перегляд, створення, редагування та видалення ліків;
–	Імпорт даних системи.
Також, програмна система має підтримувати локалізацію та інтернаціоналізацію, а саме: кодові таблиці символів, обчислення дати й часу, формат дати й часу, місцевий час, універсальний час, метричні й імперські одиниці вимірювання, порядок сортування тексту, різні напрями введення тексту.


3	ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


Для проєктування бази даних було розроблено ER-модель даних (див. рис. 3.1). Вона складається з 10 таблиць: користувачі (User), машини/мобільні аптеки (Machine), статистики приладів (MachineStatistic), зупинки машин (MachinePickupPoint), відділення із ліками у автоматах (MachineMedicineSlot), ліки (Medicine), замовлення (Order), ліки в замовленні (OrderMedicine), точки зупинки (PickupPoint).

Рисунок 3.1 – ER-діаграма проєкту
На діаграмі можна побачити такі зв’язки:
-	Користувач і Замовлення (Один до багатьох): Один користувач може розмістити багато замовлень.
-	Машина і Замовлення (Один до багатьох): Одна машина може бути використана для багатьох замовлень.
-	Машина і Статистика Машини (Один до багатьох): Одна машина може генерувати багато статистик.
-	Машина і Зупинка (Багато до багатьох): Одна машина може мати багато зупинок і навпаки.
-	Машина і Ліки (Багато до багатьох): Одна машина може містити багато різних ліків і навпаки.
-	Ліки і Замовлення (Багато до багатьох): Одні ліки можуть містити багато замовлень і навпаки.
-	Точка Зупинки і Машини (Багато до багатьох): Одна точка зупинки може бути частиною маршруту багатьох машин і навпаки.
-	Точка Зупинки і Замовлення (Один до багатьох): Одна точка зупинки може бути частиною багатьох замовлень.


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


	Для забезпечення нормалізації бази даних, варто усунути зв’язки «багато-до-багатьох» між сутностями. Усі таблиці мають бути нормалізовані, щоб задовольняти першій, другій і третій нормальним формам.

Отже, у логічній моделі бази даних будуть представлені такі сутності:
−	користувачі (User);
−	машини/мобільні аптеки (Machine);
−	статистики приладів (MachineStatistic);
−	зупинки машин (MachinePickupPoint);
−	відділення із ліками у автоматах (MachineMedicineSlot);
−	ліки (Medicine);
−	замовлення (Order);
−	ліки в замовленні (OrderMedicine);
−	точки зупинок (PickupPoint).

Створимо таблицю користувачів (User). Вона буде містити у собі такі атрибути: Id (первинний ключ), FirstName, LastName, Birthdate, Email, Password, IsSuperuser, Role.
Перевіримо таблицю User на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю автоматів (Machine). Вона буде містити у собі такі атрибути: Id (первинний ключ), Name, Location, AdminUserId (зовнішній ключ для зв’язку з таблицею User), IsOnline, Status, LastMaintenanceDate.
Перевіримо таблицю Machine на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю статистики автоматів (MachineStatistic). Вона буде містити у собі такі атрибути: Id (первинний ключ), MachineId (зовнішній ключ для зв’язку з таблицею Machine), Info.
Перевіримо таблицю MachineStatistic на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю зупинок автоматів (MachinePickupPoint). Вона буде містити у собі такі атрибути: Id (первинний ключ), MachineId (зовнішній ключ для зв’язку з таблицею Machine), PickupPointId (зовнішній ключ для зв’язку з таблицею PickupPoint), ArrivalAt, DepartureAt, DeliverOrders.
Перевіримо таблицю MachinePickupPoint на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю слотів ліків у автоматах (MachineMedicineSlot). Вона буде містити у собі такі атрибути: Id (первинний ключ), MachineId (зовнішній ключ для зв’язку з таблицею Machine), MedicineId (зовнішній ключ для зв’язку з таблицею Medicine), TotalCount, ReservedCount.
Перевіримо таблицю MachineMedicineSlot на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю ліків (Medicine). Вона буде містити у собі такі атрибути: Id (первинний ключ), Name, Type, Description, Price, Currency, PrescriptionNeeded, IsAvailable.
Перевіримо таблицю Medicine на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю замовлень (Order). Вона буде містити у собі такі атрибути: Id (первинний ключ), UserId (зовнішній ключ для зв’язку з таблицею User),MachineId (зовнішній ключ для зв’язку з таблицею Machine), PickupPointId (зовнішній ключ для зв’язку з таблицею PickupPoint), Status, PaymentAmount, PaymentCurrency, PaymentDate.
Перевіримо таблицю Order на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю ліків у замовленнях (OrderMedicine). Вона буде містити у собі такі атрибути: Id (первинний ключ), OrderId (зовнішній ключ для зв’язку з таблицею Order), MedicineId (зовнішній ключ для зв’язку з таблицею Medicine), MedicineCount.
Перевіримо таблицю OrderMedicine на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
Створимо таблицю точок зупинки (PickupPoint). Вона буде містити у собі такі атрибути: Id (первинний ключ), Location, IsAvailable.
Перевіримо таблицю PickupPoint на відповідність нормалізації:
– Усі атрибути атомарні: містять лише одне значення, а не множину;
– Відсутність повторюваності даних;
– Усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальним формам.
За результатами проектування таблиць та зв’язків майбутньої бази даних, було отримано її логічну схему, яка задовольняє першій, другій і третій нормальним формам (див. рис. 3.2).

Рисунок 3.2 – Логічна схема бази даних
Оскільки всі таблиці в логічній схемі бази даних знаходяться в третій нормальній формі, можна зробити висновок, що база даних загалом відповідає третій нормальній формі.


4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Користувачами системи є 3 типи акторів: адміністратор системи, клієнт та IoT апарат. Клієнти взаємодіють з веб-частиною, а адміністратор системи взаємодіє з веб-частиною задля адміністрування даними та мобільним додатком для реєстрації нових приладів у системі.
За допомогою веб-додатку клієнту надаються такі можливості, як авторизація та реєстрація, перегляд інформації відповідно до ролі користувача, доступ до робочої області з апаратами, а також можливість створення замовлень. Адміністратори також використовують веб-додаток для адміністрування даних про машини, ліки та облікові записи.
За допомогою мобільного додатку адміністратору надаються такі можливості, як взаємодіяти з системою для реєстрації нових автоматів (машин для продажу ліків) та внесення даних про них.
У ролі IoT-приладів виступають самі машини, які виконують процес обробки замовлень та видачі ліків. Вони також відправляють серверу власну статистику зі складом інвентаря та наявними для продажу ліками кожні 30 хвилин.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).


Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи
Для написання серверної частини системи було обрано мову програмування Python з використанням мікрофреймворку FastAPI, дозволяючи писати швидкий та продуктивний код.
Після  аналізу структури моделі програмної системи було виділено пакети, що складають систему. Ці пакети та зв’язки між ними можна побачити на Діаграмі пакетів (див. рис. 4.2).
У основному пакеті рішення Backend було виділено такі составні пакети: пакет API із контроллерами (ApiRouters), пакет бази даних із моделями та міграціями (Database), пакет сервісів (Services), пакет домену із кодом що перевикористовується в усіх інших пакетах (Domain), пакет залежностей для використання ін'єкції залежностей (dependency injection) що предоставляє фреймворк FastAPI (dependencies), для взаємодії з базою даних Postgres використовується бібліотека SQLAlchemy, а для управління міграціями використовується Alembic. Оскільки для маршрутизації запитів система використовує API контролери, розміщені в пакеті ApiRouters, вони розбивають програму на логічні компоненти, де кожен відповідає за обробку певного типу запитів. Це спрощує управління кодом та дозволяє дуже легко розширювати функціональність.  В архітектуру також були додано CORSMiddleware для забезбечення правильної роботи між веб-клієнтом та API.

Рисунок 4.2 – Діаграма пакетів серверної частини програмної системи
Для демонстрації та тестування API використовується OpenApi Swagger, зручний інструмент для перегляду та тестування API, покращує якість та зручність розробки. Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, який захищає дані під час їх передачі.
Для шифрування паролів та створення токенів авторизації використовується технологія JWT (Json Web Tokens), що надає потужний та безпечний механізм управління доступом користувачів. Для передачі та отримання даних використовується принцип REST API.
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.3).

Рисунок 4.3 – Діаграма розгортання програмної системи
Приклади коду серверної частини наведено в додатку Б. Таким чином, було визначено архітектуру та технології серверної частини програмної системи.


4.2 Архітектура ІоТ-частини


IoT частина системи взаємодіє з двома типами користувачів: адмінами/власниками машин та клієнтами, що можуть покупати медикаменти. Користувачі взаємодіють з апаратом крізь програмний застосунок, а вже програмний застосунок взаємодіє напряму по MQTT з апаратом.  Єдина пряма взаємодія з боку користувача, це можливість подивитися поточний стан машини за допомогою монітора, на який виводяться поточний стан машини та що вона робить.
Взаємодія користувачів з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4).

Рисунок 4.4 – Діаграма прецедентів ІоТ частини програмної системи
Для демонстрації функціональних можливостей IoT частини системи, було вирішено реалізувати програмний код мовою програмування Python, що відповідає обмеженням апаратних ресурсів IoT пристроїв та часто використовується у таких випадках. Для виведення інформації використовую консольний інтерфейс (CLI). Комунікація із девайсом реалізована за допомогою протоколу MQTT.
Програмна реалізація складається з таких частин:
-	MQTT брокеру, через який реалізовано спілкування серверної частини та пристрою;
-	Апаратний MQTT клієнт, який може бути запущено локально для симуляції роботи реального пристрою. Зберігає поточний стан інформації про девайс у локальний файл щоб забезпечити правильну роботу та зберігання даних між сесіями;
-	MQTT клієнт-міст, що отримує повідомлення від MQTT брокера, обробляє їх, забеспечуючи послідовну обробку у вигляді черги, та перенаправляє на HTTP API серверної частини;
-	REST API бекенду, що отримує повідомлення від клієнта-моста та обробляє їх вносячи зміни до бази даних та надсилаючи відповідь.
	Програма апаратного MQTT клієнта, дуже легко портується на реальні IoT пристрої системи Arduino, треба лише додати виклики до реальних модулів фізичного апарату.
Для написання IoT частини системи було обрано версію мови програмування Python 3.11.
Для взаємодії по MQTT використовується бібліотека paho-mqtt. Всі дані між частинами системи передаються у форматі JSON, для валідації було використано бібліотеку Pydantic. Для детальної візуалізації використаних технологій було розроблено діаграму пакетів (див. рис. 4.5).

Рисунок 4.5 -  Діаграма пакетів ІоТ частини програмної системи
	Для запуску додатку, потрібно налаштувати пристрій, увімкнути його та підключити до WiFi. Якщо пристрій новий, його потрібно зареєструвати в системі. Після цього, пристрій починає надсилати дані на сервер. Для більш детальної візуалізації взаємодії пристрою з користувачами системи було розроблено діаграму взаємодії (див. рис. 4.6).

Рисунок 4.6 – Діаграма взаємодії ІоТ частини програмної системи
Також було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7).
Рисунок 4.7 – Діаграма діяльності ІоТ частини програмної системи
	Таким чином, за допомогою діаграм пакетів, станів та діяльності були визначені основні технології та архітектура системи.
Приклад коду IoT-частини системи, що симулює реальний девайс, представлено у додатку В.
4.3 Архітектура клієнтської частини


	В розробленій системі можна виділити два типи акторів: адміністратор та клієнт.
	До потреб клієнта відносяться:
•	можливість реєстрації;
•	можливість авторизації;
•	можливість отримання та зміни власної інформації;
•	можливість отримання інформації про ліки;
•	можливість створити та переглянути історію замовлень.
До потреб адміністратора відносяться:
•	можливість додавання, редагування, видалення користувачів;
•	можливість додавання, редагування, видалення машин;
•	можливість додавання, редагування, видалення зупинок;
•	можливість додавання, редагування, видалення ліків.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.8).

Рисунок 4.8 – діаграма прецедентів клієнтської частини програмної системи
Для написання клієнтської частини системи було обрано мову програмування TypeScript з використанням бібліотеки  ReactJS, що забезпечує високу швидкість роботи додатку, зручність у розробці та тестуванні за рахунок статичної типізації TypeScript та підходу розділення компонентів. Використано бібліотеку ReactRouter для реалізації навігації по сайту.
Для реалізації елементів інтерфейсу було використано бібліотеку Chakra UI, бібліотеки з попередньо стилізованими компонентами та зручними інструментаки для кастомної стилізації.
Для реалізації локалізації інтерфейсу було використано бібліотеки i18next, next-i18n-router, що легко інтегруються до проекту, мають конфігурацію та реалізують зручну локалізацію.
Для виконання асинхронних запитів на сервер було axios, який дозволяє зручно взаємодіяти з HTTP-запитами.
Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.9).

Рисунок 4.9 – Діаграма пакетів клієнтської частини програмної системи
У розробленій клієнтській частині проєкту використовується Feature-Sliced архітектура, яка визначає структуру проєкту за допомогою шарів. Шари включають зрізи, які в свою чергу включають сегменти. Шари – це каталоги верхнього рівня застосунку. У проєкті є такі шари: api, components, hooks, pages, services, styles, utils. Шар pages визначає основні сторінки додатку з використанням рутера від ReactRouter. Шар components визначає основні компоненти системи. Шар hooks визначає основні об’єкти хуків, які використовуються для отримання доступу до станів системи. Шар api визначає основні утілити та клієнт для створення запитів до API серверної частини за допомогою axios. Шар services містить сервіси локалізації та сховища, що використовуються як контексти для передачі даних між різними компонентами, за допомогою бібліотеки zustand.
Для кращого уявлення архітектури системи було створено діаграму компонентів (див. рис. 4.10).

Рисунок 4.10 – Діаграма компонентів клієнтської частини програмної системи
Взаємодія з програмною системою починається з авторизації  - або входу в уже існуючий акаунт, або його створення. Також, створити акаунт адміна неможливо. Після авторизації, згідно ролі користувача, взаємодія розділяється на клієнта-покупця, клієнта-доставника та адміністратора.
Як покупець, клієнт має можливість подивитись свої дані та змінити їх, встановивши ПІБ, пошту, пароль та дату народження. Також перейшовши на сторінку ліків, він може переглянути перелік доступних ліків та додати у картку для замовлення. На сторінці картки користувач може редагувати інформацію замовлення та створити його. Також на сторінці власних замовлень користувач може  переглянути інсторію та статуси власних замовлень.
Адміністратор має можливість виконувати керування даними системи з панелі адміністратора. Він може напряму в базі даних керувати всіма користувачами, замовленнями, машинами, ліками та точками зупинок у базі даних та робити імпорт даних.
Для кращого уявлення про взаємодію користувачів з клієнтською частиною системи було розроблено діаграму взаємодії (див. рис. 4.11).

Рисунок 4.11 – Діаграма взаємодії клієнтської частини програмної системи
Приклади коду клієнтської частини системи представлено в додатку Г.
Таким чином, було визначено архітектуру, технології програмної системи за допомогою діаграми прецедентів, пакетів, компонентів та взаємодії.
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


	Для того, щоб запустити програму, потрібно завантажити архів з кодом програми та разархівувати його. Також, необхідно встановити останню версію програми Docker з офіційного сайту продукту, бо серверна частина програми використовує його для запуску, і встановити Node.js 20 версію та NPM, що необхідна для запуску клієнтської частини.
Для того, щоб налаштувати з’єднання програми з базою даних, потрібно створити файл .env за шляхом “apz-pzpi-21-1-matvii-boichenko/Task2/apz-pzpi-21-1- matvii-boichenko-task2” та за допомогою будь-якого текстового редактору вказати рядки із параметрами налаштувань, які будуть застосовані для серверної частини при запуску, приклад можна побачити на рисунку 5.1. Параметри включають дані для підключення до бази даних, MQTT брокера, ключ для створення JWT і т.д.

Рисунок 5.1 – Налаштування системи у файлі .env
	Далі потрібно запустити серверну та клієнтську частини системи. Для цього можна використовувати JetBrains Webstorm, яку необхідно завантажити з офіційного сайту продукту.
Наступним кроком буде запуск контейнерів із серверною частиною та MQTT брокером. Для цього у папці “apz-pzpi-21-1-matvii-boichenko/Task2/apz-pzpi-21-1- matvii-boichenko-task2” у консолі виконати команду “docker compose up –build-d”.
	Щоб запустити клієнтську частину системи треба відкрити консоль та перейти в папку  “apz-pzpi-21-1-matvii-boichenko/Task4/apz-pzpi-21-1-matvii-boichenko-task4”, з цього шляху треба запустити команду “npm install” , щоб у проєкті встановились залежності, вказані у package.json, і після цього “npm run dev”.
	Запуск ІоТ частини небхідно виконати наступні кроки: перейти у консолі до папки “apz-pzpi-21-1-matvii-boichenko/Task3/apz-pzpi-21-1-matvii-boichenko-task3”, створити python віртуальне оточення за допомогою команди “python -m venv venv”. Пере	йдемо до запуску частини API Bridge MQTT client: у консолі перейти до директорії “apz-pzpi-21-1-matvii-boichenko/Task3/apz-pzpi-21-1-matvii-boichenko-task3/api-bridge-client”, створити файл .env та налаштувати параметри програми за прикладом на рисунку 5.2, потім виконати команди: “source ../venv/bin/activate”, “pip install -r requirements.txt”, python run.py. Отже перший клієнт-черга запущена, перейдемо до запуску Client Device MQTT client за допомогою наступних команд: у консолі перейти до директорії “apz-pzpi-21-1-matvii-boichenko/Task3/apz-pzpi-21-1-matvii-boichenko-task3/device-client”, створити файл .env та налаштувати параметри програми за прикладом на рисунку 5.2, потім виконати команди: “source ../venv/bin/activate”, “pip install -r requirements.txt”, python run.py.


Рисунок 5.2 –Приклади налаштувань ІоТ-пристрою у файлі .env


5.2 Призначення і логічна структура


	Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
–	авторизація та реєстрація;
–	профіль;
–	ліки;
–	користувачі системи;
–	машини;
–	зупинки;
–	замовлення;
Модуль «Авторизація та реєстрація» містить у собі функціонал для входу в систему та реєстрації нового аккаунту. Реєстрація дає користувачу можливість створити новий запис у базі даних та завдяки ньому входити в систему, за допомогою логіну та пароля. Для того, щоб увійти як адмін/суперюзер, потрібно надати доступ напряму в базі даних або через адмін панель.
Модуль «Профіль» містить у собі функціонал перегляду та зміни інформації власного профілю, таких як ім’я, прізвище, пошту, пароль та дату народження.
Модуль «Ліки» містить у собі функціонал перегляду наявних ліків та додавання їх у кошик.
Модуль «Машини» є адміністраторським та містить у собі функціонал для створення додавання, редагування та видалення машин у системі.
Модуль «Користувачі системи» є адміністраторським та містить у собі функціонал для додавання, редагування та видалення користувачів системи.
Модуль «Зупинки» є адміністраторським та містить у собі функціонал для додавання, редагування та видалення налаштувань зупинки у системі.
Модуль «Замовлення» містить адміністраторську частину, що містить у собі функціонал для редагування та видалення налаштувань існуючих у системі та клієнтський, що дозволяє створювати замовлення.


5.3 Опис програмної реалізації


	Перше, що зустрічає користувача – це головна сторінка (див. рис. 5.3). З неї можно перейти на сторінки авторизації та реєстрації за допомогою хедеру, а також змінити мову сайту у правому верхньому куті. До вибору доступні дві мови – українська на англійська (див. рис. 5.4).

Рисунок 5.3 – Головна сторінка сайту

Рисунок 5.4 – Головна сторінка сайту українською
	На сторінці реєстрації (див. рис. 5.5) можна зареєструвати новий акаунт. Для цього потрібно ввести дані для нового користувача.

Рисунок 5.5 – Сторінка реєстрації
	На сторінці входу у вже існуючий акаунт потрібно ввести логін та пароль, щоб увійти в акаунт (див. рис. 5.6).

Рисунок 5.6 – Сторінка авторизації в систему
	Після входу користувач може зайти на сторінку профілю, натиснувши в хедері «Profile». Після цього відкриється сторінка профілю, де буде зображено інформацію користувача (див. рис. 5.7).

Рисунок 5.7 – Сторінка профілю користувача
	Користувач може змінити свої дані, потрібно натиснути «Edit Profile». Після цього, відкриється сторінка зміни інформації профілю (див. рис. 5.8).

Рисунок 5.8 – Сторінка зміни інформації профілю
	Також, користувач може вилогінитися натиснувши кнопку “Logout” та змінити пароль за допомогою попапу (див. рис. 5.9).

Рисунок 5.9 – Спливаюче вікно для зміни паролю
	Користувач також може перейти на сторінку лік (рис. 5.10) переглянути використавши пошук та фільтрування (приклад див. на рис 5.11)  та додати їх в кошик для замовлення, обравши кількість за допомогою спливаючого вікна (рис. 5.12).

Рисунок 5.10 – Сторінка лік

Рисунок 5.11 – Пошук лік з фільтруванням

Рисунок 5.12 – Спливаюче вікно для обирання кількості лік
	Після додавання бажаних ліків користувач може перейти до кошику, відредагувати нове замовлення (рис 5.13) та обрати пункт доставки (рис 5.14).

Рисунок 5.13 – Сторінка кошику

Рисунок 5.14 – Спливаюче вікно з обиранням точки доставки замовлення
	Коли замовлення було сформоване і користувач натиснув “Create Order”, його перенаправляє автоматично на сторінку всіх його замовлень (рис. 5.15), де він може дивитися загальну інформацію про них та деталі кожного з них клікнувши на нього (рис. 5.16).

Рисунок 5.15 – Сторінка історії замовлень

Рисунок 5.16 – Перегляд деталей замовлення
Далі розглянемо функціонал адміністратора. Для логіна в якості адміністратора треба перейти на доменне ім’я серверної частини по url шляху “/admin” (див. рис. 5.17), на цій сторінці йому треба ввести власні логін та пароль. На ній буде адміністративна панель (див. рис. 5.18).

Рисунок 5.16 – Сторінка входу адміністратора

Рисунок 5.16 – Головна сторінка авторизованого адміністратора
	Адміністратор має можливість переглядати із сортуванням і пошуком та редагувати будь які дані в системі, в будь яких таблицях бази даних, наприклад переглядати все ліки (див. рис. 5.17), переглядати окремо кожен об'єкт (див. рис. 5.18), редагувати кожен об'єкт (див. рис. 5.19) та видаляти його (див. рис. 5.20).

Рисунок 5.17 – Сторінка керування ліками

Рисунок 5.18 – Сторінка деталей ліків
Рисунок 5.19 – Сторінка редагування ліків

Рисунок 5.20 – Попап видалення ліків
	Також він може створювати нові ліки за допомогою кнопки “+ New” (приклад ліків див. на рис. 5.21).

Рисунок 5.21 – Створення ліків
Також, за таким самим принципом на адміністративній панелі є можливість керувати користувачами (див. рис. 5.22), машинами (див. рис. 5.23) та пов'язаними сутностіми, статистиками з машин (див. рис. 5.24), пунктами доставки (див. рис. 5.25) та замовленнями (див. рис. 5.26).

Рисунок 5.22 – Керування користувачами системи

Рисунок 5.23 – Керування машинами системи

Рисунок 5.24 – Керування статистиками з машин

Рисунок 5.25 – Керування пунктами доставки

Рисунок 5.26 – Керування замовленнями
	Крім того адміністратор може експортувати будь-які обрані дані з будь-якої колекції за допомогою кнопки “Export”, достатньо обрати бажані елементи на сторінці перегляду та натиснути на кнопку “Export” (див. рис. 5.27), після цього буде сформовано та завантажено файл csv з усіма обраними елементами, приклад якого можна побачити на рисунку 5.28.

Рисунок 5.26 – Приклад експорту даних про замовлення

Рисунок 5.26 – Приклад файлу з експортованими даними про замовлення
	Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою.


ВИСНОВКИ


	У результаті виконаної роботи було розроблено програмну систему предметної області «Програмна система для автоматизації роботи мобільних аптек».
	У процесі розробки було проанализовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, ІоТ та клієнтської частин програмної системи, а реалізовано її за допомогою FastAPI та React.
	Розроблена програмна система дозволяє користувачам створювати замовлення ліків та відстежувати їх виконання. Вона забезпечує реєстрацію та авторизацію користувачів, керування профілю. Користувачі можуть дивитись інформацію про себе, ліки у системі та власні замовлення. Крім того, в системі присутнє адміністрування. Система забезпечує стабільний репортинг даних з датчиків у машині, що адміністратор може відстежувати. Адміністратор також має можливість керувати користувачами, машинами, налаштуваннями машин, ліками, замовленнями, а також створювати експорти обраних колекцій даних.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. 	Python 3.11.8 documentation. URL: https://docs.python.org/3.11/ (дата звернення: 18.06.2024)
2.	PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL:
https://www.postgresql.org/docs/16/index.html (дата звернення: 18.06.2024)
3.	React Documentation. URL: https://react.dev/reference/react (дата звернення: 18.06.2024)
4.	Typescript documentation. URL: https://www.typescriptlang.org/docs/handbook/intro.html (дата звернення: 18.06.2024)


ДОДАТОК А
Результат перевірки на плагіат


ДОДАТОК Б
Програмний код серверної частини
1.	Бекенд частина проекту починає свою роботу з файлу main.py, що запускає сервер, за конфігураціями. Вміст цього файлу наведено нижче.
1  import os
2  from contextlib import asynccontextmanager
3
4  from fastapi import FastAPI
5  from sqlalchemy import text
6
7  from backend.config import settings
8  from backend.database import db, models
9  from backend.infrastructure.babel import babel
10 from backend.logger import configure_logger
11 from backend.services.mqtt.mqtt_service import mqtt_service
12
13
14 @asynccontextmanager
15 async def lifespan(app: FastAPI):
16     db.connect()
17     async with db.async_engine.connect() as conn:
18         await conn.execute(text(f"CREATE SCHEMA IF NOT EXISTS {settings.DATABASE_SCHEMA}"))
19         await conn.run_sync(models.BaseModel.metadata.create_all)
20         await conn.commit()
21
22     mqtt_service.connect()
23
24     yield
25
26     mqtt_service.disconnect()
27     await db.disconnect()
28
29
30 def create_app():
31     app = FastAPI(lifespan=lifespan)
32
33     babel.init_app(app)
34
35     configure_logger(logger_name="app_main", log_level="DEBUG")
36
37     from backend.api.router import api
38
39     app.include_router(api)
40
41     return app
42
43
44 app = create_app()
45
46
47 if __name__ == "__main__":
48     import uvicorn
49     print(os.environ)
50     uvicorn.run(app="main:create_app", factory=True,
51                 host="127.0.0.1", port=8001, reload=settings.DEBUG)

2.	Як приклад математичних обчислень, код методу розраховує відстань у кілометрах між двома точками географічних координат та час для проїзду цієї відстані із узагальненною швидкістю.
1  async def calculate_distance(self, request: CalculateDistanceRequest):
2      """
3      Розрахунок відстані в метрах між двома географічними координатами за формулою Гарвіна (Haversine formula)
4      :param request:
5      :return:
6      """
7      pickup_point1 = (await self.db.execute(
8          select(PickupPoint).filter(PickupPoint.id == request.pickup_point1_id))).scalar_one_or_none()
9      pickup_point2 = (await self.db.execute(
10         select(PickupPoint).filter(PickupPoint.id == request.pickup_point2_id))).scalar_one_or_none()

11     if not pickup_point1 or not pickup_point2:
12         raise Exception("Pickup point(s) not found")

13     # Extracting the coordinates
14     lat1, lon1 = pickup_point1.location['latitude'], pickup_point1.location['longitude']
15     lat2, lon2 = pickup_point2.location['latitude'], pickup_point2.location['longitude']

16     # Converting latitude and longitude from degrees to radians
17     lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])

18     # Haversine formula to calculate the distance
19     dlon = lon2 - lon1
20     dlat = lat2 - lat1
21     a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
22     c = 2 * atan2(sqrt(a), sqrt(1 - a))
23     radius_of_earth_km = 6371  # Radius of Earth in kilometers
24     distance_km = radius_of_earth_km * c
25     distance_meters = distance_km * 1000  # Convert distance to meters

26     speed_kmh = 45
27     time_hours = distance_km / speed_kmh

28     return DistanceTimeResponse(distance=distance_km, time_hours=time_hours)


ДОДАТОК В
Програмний код ІоТ пристрою
	Нижче наведено код з файлу з основною логікою IoT пристрою
1 class DeviceMQTTClient(object):
2     def __init__(self, logger: Logger):
3         self._logger: Logger = logger
4         self.machine_mac: str = os.environ["MACHINE_MAC"]
5         self.client_id: str = f"Machine-{self.machine_mac}"
6
7         self.username: str = os.environ["MQTT_USER"]
8         self.password: str = os.environ["MQTT_PASS"]
9
10         self.api_host: str = os.environ["HTTP_API_HOST"]
11         self.api_key: str = os.environ["HTTP_API_KEY"]
12
13         self.is_inited = False
14         self.mqtt_client: Client = self._get_mqtt_client()
15
16         self.path_to_machine_info: str = (
17             os.path.join(Path(os.path.abspath(__file__)).parent.parent, "machine_info.json"))
18         self.machine: MachineInfo = self._load_machine_info()
19         self._sleep_until: int = 0
20
21     def connect_client(self):
22         self.mqtt_client.loop_start()
23         self.mqtt_client.connect(
24             host=os.environ["MQTT_BROKER_HOST"],
25             port=1883,
26             keepalive=120
27         )
28
29     def _get_mqtt_client(self):
30         mqtt_client = Client(client_id=self.client_id)
31         mqtt_client.enable_logger(self._logger)
32         mqtt_client.username_pw_set(self.username, self.password)
33
34         # Set up Last Will and Testament (LWT) message
35         last_will_message = {
36             "online": False
37         }
38         last_will_topic = f"machine/{self.machine_mac}/connection"
39         mqtt_client.will_set(last_will_topic, payload=json.dumps(last_will_message), qos=1, retain=False)
40
41         mqtt_client.on_connect = self._on_connect
42         mqtt_client.on_disconnect = self._on_disconnect
43         mqtt_client.on_message = self._on_message
44         mqtt_client.on_publish = self._on_publish
45
46         return mqtt_client
47
48     def _on_publish(self, client, userdata, mid):
49         # print("Message Published.", mid)
50         pass
51
52     def _on_connect(self, client, userdata, flags, rc):
53         self._logger.debug("Connected with result code " + str(rc))
54         self._save_machine_info()
55         self.subscribe_mqtt_client_to_all_necessary_topics(self.mqtt_client)
56         self._send_initial_message()
57         self.is_inited = True
58
59     def _on_disconnect(self, client, userdata, rc):
60         self._logger.debug("Disconnected with result code " + str(rc))
61         self.is_inited = False
62
63     def _on_message(self, client, userdata, msg: MQTTMessage) -> dict | None:
64         try:
65             payload = json.loads(msg.payload.decode('utf-8')) if msg.payload else None
66             self._logger.debug(f"Received payload: {payload}")
67
68             return payload
69
70         except Exception as ex:
71             self._logger.exception(ex, exc_info=ex)
72
73     def _handle_order(self, client, userdata, msg: MQTTMessage):
74         """
75         Handle an order coming form backend
76         """
77         def handle():
78             payload = self._on_message(client, userdata, msg)
79             order = OrderInfo(**payload)
80
81             self._logger.info(f"Start executing order {order.order_id}...")
82
83             message = {"status": "start"}
84             self.mqtt_client.publish(f"machine/{self.machine_mac}/orders/{order.order_id}/event", json.dumps(message))
85
86             changes_in_inventory: dict[InventoryItemInfo, int] = {}
87             for med in order.order_medicines:
88                 inventory_item: InventoryItemInfo | None = None
89                 for item in self.machine.inventory.values():
90                     if item.medicine_type == med.medicine_type and item.medicine_name == med.medicine_name:
91                         inventory_item = item
92                         break
93
94                 if not inventory_item:
95                     self._logger.info("Failed to execute the order. Such medicine not found")
96                     message = {"status": "fail", "reason": "Such medicine not found"}
97                     self.mqtt_client.publish(f"machine/{self.machine_mac}/orders/{order.order_id}/event",
98                                              json.dumps(message))
99                     return
100
101                if inventory_item.left_amount <= 0:
102                    self._logger.info("Failed to execute the order. No medicine left")
103                    message = {"status": "fail", "reason": "No medicine left"}
104                    self.mqtt_client.publish(f"machine/{self.machine_mac}/orders/{order.order_id}/event",
105                                             json.dumps(message))
106                    return
107
108                changes_in_inventory[inventory_item] = med.count
109
110            # executing order on device, call to device module to give a medicine
111            time.sleep(5)
112
113            for inventory_item, change_count in changes_in_inventory.items():
114                inventory_item.left_amount -= change_count
115            self._save_machine_info()
116
117            self._logger.info(f"Successfully executed order {order.order_id}")
118            message = {"status": "success"}
119            self.mqtt_client.publish(f"machine/{self.machine_mac}/orders/{order.order_id}/event",
120                                     json.dumps(message))
121
122            self.force_publish_next()
123
124        ACTIONS_QUEUE.append(handle)
125
126    def _update_inventory(self, client, userdata, msg: MQTTMessage):
127        """
128            Handle an inventory update request coming from backend
129        """
130        def handle():
131            payload: None | dict[int, dict] = self._on_message(client, userdata, msg)
132
133            self._logger.info("Trying to updated inventory info...")
134
135            if not payload:
136                self._logger.info("Clearing inventory...")
137                self.machine.inventory.clear()
138            else:
139                for slot_id, slot_info in payload.items():
140                    if not slot_info:
141                        self._logger.info("Clearing inventory slot...")
142                        self.machine.inventory.pop(slot_id)
143                        continue
144
145                    new_info = {}
146                    if self.machine.inventory.get(slot_id):
147                        new_info = self.machine.inventory[slot_id].model_dump()
148                    new_info.update(slot_info)
149
150                    item_info = InventoryItemInfo(**new_info)
151                    self.machine.inventory[slot_id] = item_info
152
153            self._save_machine_info()
154            self._logger.info("Successfully updated inventory")
155
156            self.force_publish_next()
157
158        ACTIONS_QUEUE.append(handle)
159
160    def _send_initial_message(self):
161        message = {"online": True}
162        self.mqtt_client.publish(f"machine/{self.machine_mac}/connection", json.dumps(message))
163
164    def try_publish_next(self) -> bool:
165        if self._sleep_until >= datetime.now(tz=timezone.utc).timestamp():
166            return False
167
168        publish_info = self.get_next_publish_info()
169        self.mqtt_client.publish(
170            topic=publish_info.topic,
171            payload=json.dumps(publish_info.payload),
172            qos=publish_info.qos,
173            retain=publish_info.retain
174        )
175        self._logger.debug(f"Published payload: \\ \n{json.dumps(publish_info.payload, indent=3)}")
176        self._set_next_sleep_until()
177
178        return True
179
180    def force_publish_next(self) -> bool:
181        """
182        Force publish next action and reset sleep until mark
183        """
184        self._sleep_until = datetime.now(tz=timezone.utc).timestamp() - 5
185        return self.try_publish_next()
186
187    def _set_next_sleep_until(self):
188        """
189        Set next sleep until date, i.e. no message from device will be emitted
190        until current date equals to sleep until date
191        """
192        status_to_next_sleep_secs_map = {
193            MachineStatus.unregistered: 10,
194            MachineStatus.registered: 600
195        }
196        self._sleep_until = datetime.now(tz=timezone.utc).timestamp() + status_to_next_sleep_secs_map[self.machine.status]
197
198    def get_next_publish_info(self) -> PublishInfo:
199        status_to_get_info_map = {
200            MachineStatus.unregistered: self.get_register_publish_info,
201            MachineStatus.registered: self.get_status_publish_info
202        }
203        publish_info = status_to_get_info_map[self.machine.status]()
204
205        return publish_info
206
207    def get_status_publish_info(self) -> PublishInfo:
208        topic = f"machine/{self.machine_mac}/status"
209        payload = self.get_statistic()
210        publish_info_ = PublishInfo(topic=topic, payload=payload)
211
212        return publish_info_
213
214    def get_statistic(self) -> dict:
215        statistic = {
216            "mac": self.machine.mac,
217            "temperature": random.randint(15, 50),
218            "humidity": random.randint(5, 20),
219            "status": self.machine.status,
220            "firmware_version": self.machine.firmware_version,
221            "hardware_version": self.machine.hardware_version,
222 "inventory": {k: v.model_dump() for k, v in self.machine.inventory.items()}
223        }
224
225        return statistic
226
227    def get_register_publish_info(self):
228        topic = f"machine/register/req"
229        payload = {"mac": self.machine_mac}
230        publish_info_ = PublishInfo(topic=topic, payload=payload)
231
232        return publish_info_
233
234    def get_subscribe_infos(self) -> list[SubscribeInfo]:
235        """
236        Returns info about topics to which device must subscribe and subscibtion details like qos and callback
237        """
238        subscribe_infos = [
239            SubscribeInfo(topic=f"machine/{self.machine_mac}/register/resp", callback=self._register_response_callback),
240            SubscribeInfo(topic=f"machine/{self.machine_mac}/unregister", callback=self._unregister_callback)
241        ]
242
243        if self.machine.status == MachineStatus.registered:
244            subscribe_infos.extend([
245                SubscribeInfo(topic=f"machine/{self.machine_mac}/orders/new", callback=self._handle_order),
246                SubscribeInfo(topic=f"machine/{self.machine_mac}/inventory/update", callback=self._update_inventory),
247            ])
248
249        return subscribe_infos
250
251    def _unregister_callback(self, client: Client, userdata, msg: MQTTMessage):
252        payload = self._on_message(client, userdata, msg)
253        self.machine.status = MachineStatus.unregistered
254
255        self._logger.debug(f"Updated device status (unregistered). Current: {str(self.machine.status)}")
256
257        self.mqtt_client.reconnect()
258        self._set_next_sleep_until()
259
260        return True
261
262    def subscribe_mqtt_client_to_all_necessary_topics(self, mqtt_client: Client):
263        subscribe_infos = self.get_subscribe_infos()
264        for subscribe_info in subscribe_infos:
265            mqtt_client.subscribe(subscribe_info.topic, subscribe_info.qos)
266
267            if subscribe_info.callback:
268                mqtt_client.message_callback_add(subscribe_info.topic, subscribe_info.callback)
269
270    def _load_machine_info(self) -> MachineInfo:
271        """
272        Loads to class data from local file
273        """
274        try:
275            with open(self.path_to_machine_info, "r") as file:
276                info = json.load(file)
277
278            info["mac"] = self.machine_mac
279        except BaseException as ex:
280            self._logger.exception("Got error trying to open file", exc_info=ex)
281            with open(self.path_to_machine_info, "x") as file:
282                pass
283            info = {
284                "mac": self.machine_mac,
285                "firmware_version": "1.0",
286                "hardware_version": "v1",
287                "status": MachineStatus.unregistered,
288                "inventory": {}
289            }
290
291        return MachineInfo(**info)
292
293    def _save_machine_info(self, info: dict | None = None):
294        if not info:
295            info = self.machine.model_dump()
296
297        with open(self.path_to_machine_info, "w+") as file:
298            json.dump(info, file, indent=3)
299            # file.write(info)
300
301    def _register_response_callback(self, client: Client, userdata, msg: MQTTMessage) -> bool:
302        client.on_message(client, userdata, msg)
303        payload: dict = json.loads(str(msg.payload.decode("utf-8")))
304        if payload["status"] == "failure":
305            return False
306
307        if self.machine.status == MachineStatus.unregistered:
308            self.machine.status = MachineStatus.registered
309
310        self._logger.debug(f"Device with mac {self.machine_mac} successfully registered")
311        self._logger.debug(f"Current device status: {str(self.machine.status)}")
312
313        self.mqtt_client.reconnect()
314        return True
315
316    def loop(self):
317        if self.is_inited:
318            while len(ACTIONS_QUEUE) > 0:
319                try:
320                    ACTIONS_QUEUE.pop(0)()
321                except Exception as ex:
322                    self._logger.exception(ex, exc_info=ex)
323            self.try_publish_next()


ДОДАТОК Г
Програмний код клієнтської частини

Г.1 Код сторінки логіну користувача
1  import React, { useState } from 'react';
2  import { Box, Button, FormControl, FormLabel, Input, Stack, Text, useToast } from '@chakra-ui/react';
3  import { Colors } from '@styles/colors.ts';
4  import { useNavigate } from 'react-router-dom';
5  import { LoginData } from './types.ts';
6  import * as ApiClient from '@api/client';
7  import { AppStore } from "@stores/index.ts";
8  import { useTranslation } from "react-i18next";
9
10 const Login = () => {
11   const [loginData, setLoginData] = useState<LoginData>({username: '', password: ''});
12   const toast = useToast();
13   const navigate = useNavigate();
14   const userStore = AppStore.useUserStore();
15   const {t} = useTranslation();
16
17   const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
18     const {name, value} = e.target;
19     setLoginData({...loginData, [name]: value});
20   };
21
22   const handleSubmit = async (e: React.FormEvent) => {
23     e.preventDefault();
24     let data;
25     try {
26       data = await ApiClient.authJwtLoginApiV1AuthJwtLoginPost(
27         {formData: loginData});
28     } catch (e) {
29       console.log(e);
30     }
31     const isSuccessful = !!data;
32     if (isSuccessful) {
33       userStore.authorize(data.access_token);
34       toast({
35         title: t('login_success'),
36         status: 'success',
37         duration: 2000,
38         isClosable: true,
39       });
40       navigate('/profile');
41     } else {
42       toast({
43         title: t('login_fail'),
44         status: 'error',
45         duration: 2000,
46         isClosable: true,
47       });
48     }
49   };
50
51   return (
52     <Box bg={Colors.background} h='full' py={12} px={6}>
53       <Box maxW='md' mx='auto' p={8} bg={Colors.primaryBeige} borderRadius='md' boxShadow='lg'>
54         <Text fontSize='2xl' mb={6} textAlign='center' color={Colors.textRegular}>{t('login_title')}</Text>
55         <form onSubmit={handleSubmit}>
56           <Stack spacing={4}>
57             <FormControl id='email' isRequired>
58               <FormLabel>{t('username_input')}</FormLabel>
59               <Input type='username' name='username' value={loginData.username} onChange={handleChange} />
60             </FormControl>
61             <FormControl id='password' isRequired>
62               <FormLabel>{t('password_input')}</FormLabel>
63               <Input type='password' name='password' value={loginData.password} onChange={handleChange} />
64             </FormControl>
65             <Button type='submit' colorScheme='green' bg={Colors.primaryGreen} width='full'>{t('login_cta')}</Button>
66           </Stack>
67         </form>
68       </Box>
69     </Box>
70   );
71 };
72
73 export default Login;

Г.2 Код сторінки пошуку та додавання ліків у кошик
1  const Medicines = () => {
2    const [medicines, setMedicines] = useState<Medicine[]>([]);
3    const [filters, setFilters] = useState<MedicineSearchDto>({
4      simple_filters: {},
5      search_substring: '',
6      pagination: {offset: 0, limit: 10},
7      order_by: {
8        order_by_column: 'name',
9        desc: false
10     },
11   });
12   const [selectedMedicine, setSelectedMedicine] = useState<Medicine | null>(null);
13   const [quantity, setQuantity] = useState(1);
14   const {isOpen, onOpen, onClose} = useDisclosure();
15   const toast = useToast();
16   const {addToCart} = AppStore.useUserStore();
17   const {mutate: fetchMedicines} = useMutation({
18     mutationFn: async () => await ApiClient.searchMedicinesApiV1MedicinesSearchPost({
19       requestBody: filters,
20     }),
21     onSuccess: (data) => {
22       setMedicines(data);
23     },
24     onError: error => {
25       console.log('fetchMedicines err', error)
26       toast({
27         title: 'Error fetching medicines',
28         status: 'error',
29         duration: 2000,
30         isClosable: true,
31       });
32     },
33   });
34
35   useEffect(() => {
36     fetchMedicines();
37   }, [filters.pagination]);
38
39   const handleFilterChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
40     const {name, value, type} = e.target;
41     console.log('e.target', type, name, value);
42     let newValue: string | undefined = value;
43     if (type === 'select-one' && value === 'any')
44       newValue = undefined;
45     setFilters({
46       ...filters,
47       simple_filters: {
48         ...filters.simple_filters,
49         [name]: newValue,
50       },
51     });
52   };
53
54   const handlePaginationChange = (offset: number) => {
55     setFilters({
56       ...filters,
57       pagination: {
58         ...filters.pagination,
59         offset,
60       },
61     });
62   };
63
64   const handleOrderChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
65     const {name, value} = e.target;
66     setFilters({
67       ...filters,
68       order_by: {
69         ...filters.order_by,
70         [name]: value === 'true',
71       },
72     });
73   };
74
75   const handleAddToCart = () => {
76     if (selectedMedicine) {
77       addToCart(selectedMedicine, quantity);
78       toast({
79         title: 'Medicine added to cart',
80         status: 'success',
81         duration: 2000,
82         isClosable: true,
83       });
84       onClose();
85     }
86   };
87
88   return (
89     <Box bg={Colors.lightBeige} h='full' px={6}>
90       <Box w='full'>
91         <Text fontSize='2xl' my={6} textAlign='center' color={Colors.textRegular}>Available Medicines</Text>
92         <Stack direction={{base: 'column', lg: 'row'}}
93                spacing={4}
94                mb={6}
95                bg={Colors.primaryBeige}
96                p={8}
97                borderRadius='md'
98                boxShadow='lg'>
99           <FormControl>
100            <FormLabel>Search substring</FormLabel>
101            <Input type='text' name='search_substring' onChange={(e) => {
102              setFilters({...filters, search_substring: e.target.value,});
103            }} value={filters.search_substring || ''} />
104          </FormControl>
105          <FormControl>
106            <FormLabel>Prescription Needed</FormLabel>
107            <Select name='prescription_needed' onChange={handleFilterChange} defaultValue='any'>
108              <option value='true'>Yes</option>
109              <option value='false'>No</option>
110              <option value='any'>Any</option>
111            </Select>
112          </FormControl>
113          <FormControl>
114            <FormLabel>Order By Name</FormLabel>
115            <Select name='desc' onChange={handleOrderChange} value={filters.order_by?.desc + ''}>
116              <option value='true'>Descending</option>
117              <option value='false'>Ascending</option>
118            </Select>
119          </FormControl>
120          <Button minW='200px' alignSelf='end' colorScheme='green' onClick={() => fetchMedicines()}>
121            Search
122          </Button>
123        </Stack>
124        <Grid templateColumns='repeat(auto-fill, minmax(250px, 1fr))' gap={6}>
125          {medicines.map((medicine) => (
126            <MedicineCard key={medicine.id} medicine={medicine} onAddToCart={() => {
127              setSelectedMedicine(medicine);
128              onOpen();
129            }} />
130          ))}
131        </Grid>
132        <Flex align={'center'} justifyContent='center' my={6}>
133          <Button w='100px' onClick={() => (filters.pagination?.offset !== undefined
134            && handlePaginationChange(filters.pagination.offset - 10))} isDisabled={filters?.pagination?.offset === 0}>
135            Previous
136          </Button>
137          <Button w='100px' onClick={() => (filters.pagination?.offset !== undefined
138            && handlePaginationChange(filters.pagination.offset + 10))} isDisabled={medicines.length < 10}>
139            Next
140          </Button>
141        </Flex>
142      </Box>
143
144      <Modal isOpen={isOpen} onClose={onClose} isCentered>
145        <ModalOverlay />
146        <ModalContent>
147          <ModalHeader>Add to Cart</ModalHeader>
148          <ModalCloseButton />
149          <ModalBody>
150            <FormControl>
151              <FormLabel>Quantity</FormLabel>
152              <Input type='number' value={quantity} onChange={(e) => setQuantity(Number(e.target.value))} min={1} />
153            </FormControl>
154          </ModalBody>
155          <ModalFooter>
156            <Button variant='outline' mr={3} onClick={onClose}>Cancel</Button>
157            <Button colorScheme='green' onClick={handleAddToCart}>Add</Button>
158          </ModalFooter>
159        </ModalContent>
160      </Modal>
161    </Box>
162   );
163 };
164
165 export default Medicines;

Г.3 Код з модуля, що декларує моделі для таблиць у aдміністративній панелі
1  import sqlalchemy
2  from sqladmin import BaseView
3  from sqladmin import ModelView
4  from sqladmin import expose
5  from sqlalchemy import sql
6  from sqlalchemy import text
7  from sqlalchemy.orm import Session
8  from starlette.requests import Request
9
10 from database import db
11 from database.models import Machine
12 from database.models import MachineMedicineSlot
13 from database.models import MachinePickupPoint
14 from database.models import MachineStatistic
15 from database.models import Medicine
16 from database.models import Order
17 from database.models import OrderMedicine
18 from database.models import PickupPoint
19 from database.models import User
20
21
22 class UserView(ModelView, model=User):
23     column_list = [User.id, User.email, User.birthdate, User.first_name, User.last_name]
24     column_searchable_list = [User.id, User.email, User.first_name, User.last_name]
25     column_sortable_list = [User.id, User.email, User.birthdate]
26
27
28 class MachineView(ModelView, model=Machine):
29     column_list = [Machine.id, Machine.name, Machine.mac, Machine.location, Machine.admin_user_id,
30                    Machine.is_online, Machine.status, Machine.last_maintenance_date]
31     column_searchable_list = [Machine.id, Machine.name, Machine.mac]
32     column_sortable_list = [Machine.id, Machine.name, Machine.status]
33     column_details_exclude_list = [Machine.machine_pickup_points]
34     form_excluded_columns = column_details_exclude_list
35
36
37 class MachineMedicineSlotView(ModelView, model=MachineMedicineSlot):
38     column_list = [MachineMedicineSlot.machine_id, MachineMedicineSlot.medicine_id, MachineMedicineSlot.created_at,
39                    MachineMedicineSlot.updated_at, MachineMedicineSlot.total_count, MachineMedicineSlot.reserved_count]
40     column_searchable_list = [MachineMedicineSlot.machine_id, MachineMedicineSlot.medicine_id]
41     column_sortable_list = [MachineMedicineSlot.machine_id, MachineMedicineSlot.created_at,
42                             MachineMedicineSlot.updated_at]
43
44
45 class MachineStatisticView(ModelView, model=MachineStatistic):
46     column_list = [MachineStatistic.machine_id, MachineStatistic.created_at, MachineStatistic.updated_at,
47                    MachineStatistic.info]
48     column_searchable_list = [MachineStatistic.machine_id]
49     column_sortable_list = [MachineStatistic.machine_id, MachineStatistic.created_at, MachineStatistic.updated_at]
50
51
52 class MachinePickupPointView(ModelView, model=MachinePickupPoint):
53     column_list = [*MachinePickupPoint.__table__.columns]
54     column_searchable_list = [MachinePickupPoint.id, MachinePickupPoint.machine_id, MachinePickupPoint.pickup_point]
55     column_sortable_list = [MachinePickupPoint.id, MachinePickupPoint.created_at, MachinePickupPoint.updated_at]
56
57
58 class OrderView(ModelView, model=Order):
59     machine_mac = sql.select(Machine.mac).where(Machine.id == Order.machine_id).label('machine_name')
60     column_list = [Order.id, Order.user_id, Order.machine_id, Order.pickup_point_id, Order.status,
61                    Order.payment_amount, Order.payment_currency, Order.payment_date,
62                    Order.created_at, Order.updated_at, machine_mac]
63     column_searchable_list = [Order.id, Order.user_id]
64     column_sortable_list = [Order.id, Order.payment_amount, Order.created_at, Order.updated_at,
65                             Order.payment_date]
66     column_details_exclude_list = [Order.order_medicines]
67     form_excluded_columns = column_details_exclude_list
68
69
70 class OrderMedicineView(ModelView, model=OrderMedicine):
71     column_list = [*OrderMedicine.__table__.columns]
72     column_searchable_list = [OrderMedicine.order_id, OrderMedicine.medicine_id]
73     column_sortable_list = [OrderMedicine.order_id, OrderMedicine.created_at, OrderMedicine.updated_at]
74
75
76 class PickupPointView(ModelView, model=PickupPoint):
77     column_list = [*PickupPoint.__table__.columns]
78     column_searchable_list = [PickupPoint.id, PickupPoint.location]
79     column_sortable_list = [PickupPoint.id, PickupPoint.created_at, PickupPoint.updated_at]
80
81
82 class MedicineView(ModelView, model=Medicine):
83     column_list = [Medicine.id, Medicine.name, Medicine.description, Medicine.price, Medicine.currency,
84                    Medicine.is_available]
85     column_searchable_list = [Medicine.id, Medicine.name]
86     column_sortable_list = [Medicine.id, Medicine.name, Medicine.price, Medicine.is_available]